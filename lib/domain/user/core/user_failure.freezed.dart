// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'user_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$UserFailureTearOff {
  const _$UserFailureTearOff();

  UsernameNotAvailable<T> usernameNotAvailable<T>() {
    return UsernameNotAvailable<T>();
  }

  UnavailableConnection<T> unavailableConnection<T>() {
    return UnavailableConnection<T>();
  }

  UserDocInexistent<T> userDocInexistent<T>() {
    return UserDocInexistent<T>();
  }
}

/// @nodoc
const $UserFailure = _$UserFailureTearOff();

/// @nodoc
mixin _$UserFailure<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() usernameNotAvailable,
    required TResult Function() unavailableConnection,
    required TResult Function() userDocInexistent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? usernameNotAvailable,
    TResult Function()? unavailableConnection,
    TResult Function()? userDocInexistent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? usernameNotAvailable,
    TResult Function()? unavailableConnection,
    TResult Function()? userDocInexistent,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UsernameNotAvailable<T> value)
        usernameNotAvailable,
    required TResult Function(UnavailableConnection<T> value)
        unavailableConnection,
    required TResult Function(UserDocInexistent<T> value) userDocInexistent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UsernameNotAvailable<T> value)? usernameNotAvailable,
    TResult Function(UnavailableConnection<T> value)? unavailableConnection,
    TResult Function(UserDocInexistent<T> value)? userDocInexistent,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UsernameNotAvailable<T> value)? usernameNotAvailable,
    TResult Function(UnavailableConnection<T> value)? unavailableConnection,
    TResult Function(UserDocInexistent<T> value)? userDocInexistent,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserFailureCopyWith<T, $Res> {
  factory $UserFailureCopyWith(
          UserFailure<T> value, $Res Function(UserFailure<T>) then) =
      _$UserFailureCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$UserFailureCopyWithImpl<T, $Res>
    implements $UserFailureCopyWith<T, $Res> {
  _$UserFailureCopyWithImpl(this._value, this._then);

  final UserFailure<T> _value;
  // ignore: unused_field
  final $Res Function(UserFailure<T>) _then;
}

/// @nodoc
abstract class $UsernameNotAvailableCopyWith<T, $Res> {
  factory $UsernameNotAvailableCopyWith(UsernameNotAvailable<T> value,
          $Res Function(UsernameNotAvailable<T>) then) =
      _$UsernameNotAvailableCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$UsernameNotAvailableCopyWithImpl<T, $Res>
    extends _$UserFailureCopyWithImpl<T, $Res>
    implements $UsernameNotAvailableCopyWith<T, $Res> {
  _$UsernameNotAvailableCopyWithImpl(UsernameNotAvailable<T> _value,
      $Res Function(UsernameNotAvailable<T>) _then)
      : super(_value, (v) => _then(v as UsernameNotAvailable<T>));

  @override
  UsernameNotAvailable<T> get _value => super._value as UsernameNotAvailable<T>;
}

/// @nodoc

class _$UsernameNotAvailable<T> implements UsernameNotAvailable<T> {
  const _$UsernameNotAvailable();

  @override
  String toString() {
    return 'UserFailure<$T>.usernameNotAvailable()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is UsernameNotAvailable<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() usernameNotAvailable,
    required TResult Function() unavailableConnection,
    required TResult Function() userDocInexistent,
  }) {
    return usernameNotAvailable();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? usernameNotAvailable,
    TResult Function()? unavailableConnection,
    TResult Function()? userDocInexistent,
  }) {
    return usernameNotAvailable?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? usernameNotAvailable,
    TResult Function()? unavailableConnection,
    TResult Function()? userDocInexistent,
    required TResult orElse(),
  }) {
    if (usernameNotAvailable != null) {
      return usernameNotAvailable();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UsernameNotAvailable<T> value)
        usernameNotAvailable,
    required TResult Function(UnavailableConnection<T> value)
        unavailableConnection,
    required TResult Function(UserDocInexistent<T> value) userDocInexistent,
  }) {
    return usernameNotAvailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UsernameNotAvailable<T> value)? usernameNotAvailable,
    TResult Function(UnavailableConnection<T> value)? unavailableConnection,
    TResult Function(UserDocInexistent<T> value)? userDocInexistent,
  }) {
    return usernameNotAvailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UsernameNotAvailable<T> value)? usernameNotAvailable,
    TResult Function(UnavailableConnection<T> value)? unavailableConnection,
    TResult Function(UserDocInexistent<T> value)? userDocInexistent,
    required TResult orElse(),
  }) {
    if (usernameNotAvailable != null) {
      return usernameNotAvailable(this);
    }
    return orElse();
  }
}

abstract class UsernameNotAvailable<T> implements UserFailure<T> {
  const factory UsernameNotAvailable() = _$UsernameNotAvailable<T>;
}

/// @nodoc
abstract class $UnavailableConnectionCopyWith<T, $Res> {
  factory $UnavailableConnectionCopyWith(UnavailableConnection<T> value,
          $Res Function(UnavailableConnection<T>) then) =
      _$UnavailableConnectionCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$UnavailableConnectionCopyWithImpl<T, $Res>
    extends _$UserFailureCopyWithImpl<T, $Res>
    implements $UnavailableConnectionCopyWith<T, $Res> {
  _$UnavailableConnectionCopyWithImpl(UnavailableConnection<T> _value,
      $Res Function(UnavailableConnection<T>) _then)
      : super(_value, (v) => _then(v as UnavailableConnection<T>));

  @override
  UnavailableConnection<T> get _value =>
      super._value as UnavailableConnection<T>;
}

/// @nodoc

class _$UnavailableConnection<T> implements UnavailableConnection<T> {
  const _$UnavailableConnection();

  @override
  String toString() {
    return 'UserFailure<$T>.unavailableConnection()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is UnavailableConnection<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() usernameNotAvailable,
    required TResult Function() unavailableConnection,
    required TResult Function() userDocInexistent,
  }) {
    return unavailableConnection();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? usernameNotAvailable,
    TResult Function()? unavailableConnection,
    TResult Function()? userDocInexistent,
  }) {
    return unavailableConnection?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? usernameNotAvailable,
    TResult Function()? unavailableConnection,
    TResult Function()? userDocInexistent,
    required TResult orElse(),
  }) {
    if (unavailableConnection != null) {
      return unavailableConnection();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UsernameNotAvailable<T> value)
        usernameNotAvailable,
    required TResult Function(UnavailableConnection<T> value)
        unavailableConnection,
    required TResult Function(UserDocInexistent<T> value) userDocInexistent,
  }) {
    return unavailableConnection(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UsernameNotAvailable<T> value)? usernameNotAvailable,
    TResult Function(UnavailableConnection<T> value)? unavailableConnection,
    TResult Function(UserDocInexistent<T> value)? userDocInexistent,
  }) {
    return unavailableConnection?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UsernameNotAvailable<T> value)? usernameNotAvailable,
    TResult Function(UnavailableConnection<T> value)? unavailableConnection,
    TResult Function(UserDocInexistent<T> value)? userDocInexistent,
    required TResult orElse(),
  }) {
    if (unavailableConnection != null) {
      return unavailableConnection(this);
    }
    return orElse();
  }
}

abstract class UnavailableConnection<T> implements UserFailure<T> {
  const factory UnavailableConnection() = _$UnavailableConnection<T>;
}

/// @nodoc
abstract class $UserDocInexistentCopyWith<T, $Res> {
  factory $UserDocInexistentCopyWith(UserDocInexistent<T> value,
          $Res Function(UserDocInexistent<T>) then) =
      _$UserDocInexistentCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$UserDocInexistentCopyWithImpl<T, $Res>
    extends _$UserFailureCopyWithImpl<T, $Res>
    implements $UserDocInexistentCopyWith<T, $Res> {
  _$UserDocInexistentCopyWithImpl(
      UserDocInexistent<T> _value, $Res Function(UserDocInexistent<T>) _then)
      : super(_value, (v) => _then(v as UserDocInexistent<T>));

  @override
  UserDocInexistent<T> get _value => super._value as UserDocInexistent<T>;
}

/// @nodoc

class _$UserDocInexistent<T> implements UserDocInexistent<T> {
  const _$UserDocInexistent();

  @override
  String toString() {
    return 'UserFailure<$T>.userDocInexistent()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is UserDocInexistent<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() usernameNotAvailable,
    required TResult Function() unavailableConnection,
    required TResult Function() userDocInexistent,
  }) {
    return userDocInexistent();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? usernameNotAvailable,
    TResult Function()? unavailableConnection,
    TResult Function()? userDocInexistent,
  }) {
    return userDocInexistent?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? usernameNotAvailable,
    TResult Function()? unavailableConnection,
    TResult Function()? userDocInexistent,
    required TResult orElse(),
  }) {
    if (userDocInexistent != null) {
      return userDocInexistent();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UsernameNotAvailable<T> value)
        usernameNotAvailable,
    required TResult Function(UnavailableConnection<T> value)
        unavailableConnection,
    required TResult Function(UserDocInexistent<T> value) userDocInexistent,
  }) {
    return userDocInexistent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UsernameNotAvailable<T> value)? usernameNotAvailable,
    TResult Function(UnavailableConnection<T> value)? unavailableConnection,
    TResult Function(UserDocInexistent<T> value)? userDocInexistent,
  }) {
    return userDocInexistent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UsernameNotAvailable<T> value)? usernameNotAvailable,
    TResult Function(UnavailableConnection<T> value)? unavailableConnection,
    TResult Function(UserDocInexistent<T> value)? userDocInexistent,
    required TResult orElse(),
  }) {
    if (userDocInexistent != null) {
      return userDocInexistent(this);
    }
    return orElse();
  }
}

abstract class UserDocInexistent<T> implements UserFailure<T> {
  const factory UserDocInexistent() = _$UserDocInexistent<T>;
}
